Using separate 32 bit ports for dirn/step control.
--- grbl-master/limits.c	2014-08-22 06:37:05.000000000 -0700
+++ grbl-master/limits.c	2014-08-22 06:41:04.000000000 -0700
@@ -18,7 +18,7 @@
   You should have received a copy of the GNU General Public License
   along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
 */
-  
+
 #include "stepper.h"
 #include "settings.h"
 #include "nuts_bolts.h"
@@ -32,46 +32,38 @@
 
 #define MICROSECONDS_PER_ACCELERATION_TICK  (1000000/ACCELERATION_TICKS_PER_SECOND)
 
-void limits_init() 
+void limits_init()
 {
-  LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
-  #ifndef LIMIT_SWITCHES_ACTIVE_HIGH
-    LIMIT_PORT |= (LIMIT_MASK); // Enable internal pull-up resistors. Normal high operation.
-  #else // LIMIT_SWITCHES_ACTIVE_HIGH
-    LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
-  #endif // !LIMIT_SWITCHES_ACTIVE_HIGH
   if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
-    LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
-    PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
+    limits_enabled = 1; // Enable
   } else {
-    LIMIT_PCMSK &= ~LIMIT_MASK; // Disable
-    PCICR &= ~(1 << LIMIT_INT); 
+    limits_enabled = 0; // Disable
   }
 }
 
-// This is the Limit Pin Change Interrupt, which handles the hard limit feature. A bouncing 
+// This is the Limit Pin Change Interrupt, which handles the hard limit feature. A bouncing
 // limit switch can cause a lot of problems, like false readings and multiple interrupt calls.
 // If a switch is triggered at all, something bad has happened and treat it as such, regardless
-// if a limit switch is being disengaged. It's impossible to reliably tell the state of a 
+// if a limit switch is being disengaged. It's impossible to reliably tell the state of a
 // bouncing pin without a debouncing method.
 // NOTE: Do not attach an e-stop to the limit pins, because this interrupt is disabled during
 // homing cycles and will not respond correctly. Upon user request or need, there may be a
 // special pinout for an e-stop, but it is generally recommended to just directly connect
 // your e-stop switch to the Arduino reset pin, since it is the most correct way to do this.
-ISR(LIMIT_INT_vect) 
+void limits_isr(void)
 {
   // TODO: This interrupt may be used to manage the homing cycle directly with the main stepper
-  // interrupt without adding too much to it. All it would need is some way to stop one axis 
+  // interrupt without adding too much to it. All it would need is some way to stop one axis
   // when its limit is triggered and continue the others. This may reduce some of the code, but
   // would make Grbl a little harder to read and understand down road. Holding off on this until
   // we move on to new hardware or flash space becomes an issue. If it ain't broke, don't fix it.
 
   // Ignore limit switches if already in an alarm state or in-process of executing an alarm.
-  // When in the alarm state, Grbl should have been reset or will force a reset, so any pending 
-  // moves in the planner and serial buffers are all cleared and newly sent blocks will be 
+  // When in the alarm state, Grbl should have been reset or will force a reset, so any pending
+  // moves in the planner and serial buffers are all cleared and newly sent blocks will be
   // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
   // limit setting if their limits are constantly triggering after a reset and move their axes.
-  if (sys.state != STATE_ALARM) { 
+  if (sys.state != STATE_ALARM) {
     if (bit_isfalse(sys.execute,EXEC_ALARM)) {
       mc_reset(); // Initiate system kill.
       sys.execute |= EXEC_CRIT_EVENT; // Indicate hard limit critical event
@@ -81,14 +73,14 @@
 
 
 // Moves all specified axes in same specified direction (positive=true, negative=false)
-// and at the homing rate. Homing is a special motion case, where there is only an 
-// acceleration followed by abrupt asynchronous stops by each axes reaching their limit 
-// switch independently. Instead of shoehorning homing cycles into the main stepper 
-// algorithm and overcomplicate things, a stripped-down, lite version of the stepper 
+// and at the homing rate. Homing is a special motion case, where there is only an
+// acceleration followed by abrupt asynchronous stops by each axes reaching their limit
+// switch independently. Instead of shoehorning homing cycles into the main stepper
+// algorithm and overcomplicate things, a stripped-down, lite version of the stepper
 // algorithm is written here. This also lets users hack and tune this code freely for
 // their own particular needs without affecting the rest of Grbl.
 // NOTE: Only the abort runtime command can interrupt this process.
-static void homing_cycle(uint8_t cycle_mask, int8_t pos_dir, bool invert_pin, float homing_rate) 
+static void homing_cycle(uint8_t cycle_mask, int8_t pos_dir, bool invert_pin, float homing_rate)
 {
   #ifdef LIMIT_SWITCHES_ACTIVE_HIGH
     // When in an active-high switch configuration, invert_pin needs to be adjusted.
@@ -96,29 +88,29 @@
   #endif
 
   // Determine governing axes with finest step resolution per distance for the Bresenham
-  // algorithm. This solves the issue when homing multiple axes that have different 
+  // algorithm. This solves the issue when homing multiple axes that have different
   // resolutions without exceeding system acceleration setting. It doesn't have to be
-  // perfect since homing locates machine zero, but should create for a more consistent 
+  // perfect since homing locates machine zero, but should create for a more consistent
   // and speedy homing routine.
-  // NOTE: For each axes enabled, the following calculations assume they physically move 
+  // NOTE: For each axes enabled, the following calculations assume they physically move
   // an equal distance over each time step until they hit a limit switch, aka dogleg.
   uint32_t steps[3];
   uint8_t dist = 0;
   clear_vector(steps);
-  if (cycle_mask & (1<<X_AXIS)) { 
+  if (cycle_mask & (1<<X_AXIS)) {
     dist++;
-    steps[X_AXIS] = lround(settings.steps_per_mm[X_AXIS]); 
+    steps[X_AXIS] = lround(settings.steps_per_mm[X_AXIS]);
   }
-  if (cycle_mask & (1<<Y_AXIS)) { 
+  if (cycle_mask & (1<<Y_AXIS)) {
     dist++;
-    steps[Y_AXIS] = lround(settings.steps_per_mm[Y_AXIS]); 
+    steps[Y_AXIS] = lround(settings.steps_per_mm[Y_AXIS]);
   }
   if (cycle_mask & (1<<Z_AXIS)) {
     dist++;
     steps[Z_AXIS] = lround(settings.steps_per_mm[Z_AXIS]);
   }
-  uint32_t step_event_count = max(steps[X_AXIS], max(steps[Y_AXIS], steps[Z_AXIS]));  
-  
+  uint32_t step_event_count = max(steps[X_AXIS], max(steps[Y_AXIS], steps[Z_AXIS]));
+
   // To ensure global acceleration is not exceeded, reduce the governing axes nominal rate
   // by adjusting the actual axes distance traveled per step. This is the same procedure
   // used in the main planner to account for distance traveled when moving multiple axes.
@@ -128,12 +120,12 @@
 
   // Compute the adjusted step rate change with each acceleration tick. (in step/min/acceleration_tick)
   uint32_t delta_rate = ceil( ds*settings.acceleration/(60*ACCELERATION_TICKS_PER_SECOND));
-  
+
   #ifdef HOMING_RATE_ADJUST
     // Adjust homing rate so a multiple axes moves all at the homing rate independently.
     homing_rate *= sqrt(dist); // Eq. only works if axes values are 1 or 0.
   #endif
-  
+
   // Nominal and initial time increment per step. Nominal should always be greater then 3
   // usec, since they are based on the same parameters as the main stepper routine. Initial
   // is based on the MINIMUM_STEPS_PER_MINUTE config. Since homing feed can be very slow,
@@ -141,12 +133,15 @@
   uint32_t dt_min = lround(1000000*60/(ds*homing_rate)); // Cruising (usec/step)
   uint32_t dt = 1000000*60/MINIMUM_STEPS_PER_MINUTE; // Initial (usec/step)
   if (dt > dt_min) { dt = dt_min; } // Disable acceleration for very slow rates.
-      
-  // Set default out_bits. 
-  uint8_t out_bits0 = settings.invert_mask;
-  out_bits0 ^= (settings.homing_dir_mask & DIRECTION_MASK); // Apply homing direction settings
-  if (!pos_dir) { out_bits0 ^= DIRECTION_MASK; }   // Invert bits, if negative dir.
-  
+
+  // Set default step/dirn bits.
+  uint16_t step_bits0 = settings.step_invert_mask;
+  uint16_t dirn_bits = settings.dirn_invert_mask;
+  dirn_bits ^= (settings.homing_dir_mask & DIRECTION_MASK); // Apply homing direction settings
+  if (!pos_dir) { dirn_bits ^= DIRECTION_MASK; }   // Invert bits, if negative dir.
+  dirn_wr(dirn_bits);
+  step_wr(step_bits0);
+
   // Initialize stepping variables
   int32_t counter_x = -(step_event_count >> 1); // Bresenham counters
   int32_t counter_y = counter_x;
@@ -154,23 +149,23 @@
   uint32_t step_delay = dt-settings.pulse_microseconds;  // Step delay after pulse
   uint32_t step_rate = 0;  // Tracks step rate. Initialized from 0 rate. (in step/min)
   uint32_t trap_counter = MICROSECONDS_PER_ACCELERATION_TICK/2; // Acceleration trapezoid counter
-  uint8_t out_bits;
-  uint8_t limit_state;
+  uint16_t step_bits;
+  uint32_t limit_state;
   for(;;) {
-  
-    // Reset out bits. Both direction and step pins appropriately inverted and set.
-    out_bits = out_bits0;
-    
+
+    // Reset step bits. Step pins appropriately inverted and set.
+    step_bits = step_bits0;
+
     // Get limit pin state.
-    limit_state = LIMIT_PIN;
+    limit_state = debounce_rd();
     if (invert_pin) { limit_state ^= LIMIT_MASK; } // If leaving switch, invert to move.
-    
+
     // Set step pins by Bresenham line algorithm. If limit switch reached, disable and
     // flag for completion.
     if (cycle_mask & (1<<X_AXIS)) {
       counter_x += steps[X_AXIS];
       if (counter_x > 0) {
-        if (limit_state & (1<<X_LIMIT_BIT)) { out_bits ^= (1<<X_STEP_BIT); }
+        if (limit_state & (1<<X_LIMIT_BIT)) { step_bits ^= (1<<X_STEP_BIT); }
         else { cycle_mask &= ~(1<<X_AXIS); }
         counter_x -= step_event_count;
       }
@@ -178,7 +173,11 @@
     if (cycle_mask & (1<<Y_AXIS)) {
       counter_y += steps[Y_AXIS];
       if (counter_y > 0) {
-        if (limit_state & (1<<Y_LIMIT_BIT)) { out_bits ^= (1<<Y_STEP_BIT); }
+#if defined(AXES_XYZY)
+        if (limit_state & (1 << Y_LIMIT_BIT)) {step_bits ^= ((1 << Y_STEP_BIT) | (1 << A_STEP_BIT));}
+#else
+        if (limit_state & (1 << Y_LIMIT_BIT)) {step_bits ^= (1 << Y_STEP_BIT);}
+#endif
         else { cycle_mask &= ~(1<<Y_AXIS); }
         counter_y -= step_event_count;
       }
@@ -186,23 +185,23 @@
     if (cycle_mask & (1<<Z_AXIS)) {
       counter_z += steps[Z_AXIS];
       if (counter_z > 0) {
-        if (limit_state & (1<<Z_LIMIT_BIT)) { out_bits ^= (1<<Z_STEP_BIT); }
+        if (limit_state & (1<<Z_LIMIT_BIT)) { step_bits ^= (1<<Z_STEP_BIT); }
         else { cycle_mask &= ~(1<<Z_AXIS); }
         counter_z -= step_event_count;
       }
-    }        
-    
+    }
+
     // Check if we are done or for system abort
     if (!(cycle_mask) || (sys.execute & EXEC_RESET)) { return; }
-        
+
     // Perform step.
-    STEPPING_PORT = (STEPPING_PORT & ~STEP_MASK) | (out_bits & STEP_MASK);
+    step_wr(step_bits);
     delay_us(settings.pulse_microseconds);
-    STEPPING_PORT = out_bits0;
+    step_wr(step_bits0);
     delay_us(step_delay);
-    
+
     // Track and set the next step delay, if required. This routine uses another Bresenham
-    // line algorithm to follow the constant acceleration line in the velocity and time 
+    // line algorithm to follow the constant acceleration line in the velocity and time
     // domain. This is a lite version of the same routine used in the main stepper program.
     if (dt > dt_min) { // Unless cruising, check for time update.
       trap_counter += dt; // Track time passed since last update.
@@ -218,11 +217,11 @@
 }
 
 
-void limits_go_home() 
-{  
+void limits_go_home()
+{
   // Enable only the steppers, not the cycle. Cycle should be inactive/complete.
   st_wake_up();
-  
+
   // Search to engage all axes limit switches at faster homing seek rate.
   homing_cycle(HOMING_SEARCH_CYCLE_0, true, false, settings.homing_seek_rate);  // Search cycle 0
   #ifdef HOMING_SEARCH_CYCLE_1
@@ -232,7 +231,7 @@
     homing_cycle(HOMING_SEARCH_CYCLE_2, true, false, settings.homing_seek_rate);  // Search cycle 2
   #endif
   delay_ms(settings.homing_debounce_delay); // Delay to debounce signal
-    
+
   // Now in proximity of all limits. Carefully leave and approach switches in multiple cycles
   // to precisely hone in on the machine zero location. Moves at slower homing feed rate.
   int8_t n_cycle = N_HOMING_LOCATE_CYCLE;
@@ -240,7 +239,7 @@
     // Leave all switches to release them. After cycles complete, this is machine zero.
     homing_cycle(HOMING_LOCATE_CYCLE, false, true, settings.homing_feed_rate);
     delay_ms(settings.homing_debounce_delay);
-    
+
     if (n_cycle > 0) {
       // Re-approach all switches to re-engage them.
       homing_cycle(HOMING_LOCATE_CYCLE, true, false, settings.homing_feed_rate);
@@ -248,5 +247,5 @@
     }
   }
 
-  st_go_idle(); // Call main stepper shutdown routine.  
+  st_go_idle(); // Call main stepper shutdown routine.
 }
